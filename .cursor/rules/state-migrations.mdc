---
description: State/settings versioning and migrations — one step per version, loop until current
globs: **/store*.ts,**/state*.ts
alwaysApply: false
---

# State migrations (versioned persistence)

Global app state lives in `store.ts` and is persisted to LocalStorage. When persisting with a **version number**:

1. **One migration per version step**  
   Provide a function for each adjacent pair: `migrateV1ToV2`, `migrateV2ToV3`, etc.  
   Do **not** skip versions (e.g. no direct `migrateV1ToV3`). This keeps very old state upgradable and keeps each migration small and testable.

2. **Keep every migration function**  
   Do not remove old migrations when adding a new version. Users or installs may still have state at an older version.  
   Example: when introducing `SETTINGS_VERSION = 4`, add `migrateV3ToV4` and keep `migrateV1ToV2` and `migrateV2ToV3`.

3. **Run migrations in a loop until current**  
   In your load function, run migrations step by step until the state’s version equals the current `SETTINGS_VERSION`:

   ```ts
   function migrateToLatest(parsed: { version?: number }): AppState {
     let state = parsed;
     while (state.version !== SETTINGS_VERSION) {
       if (state.version === 1) state = migrateV1ToV2(state);
       else if (state.version === 2) state = migrateV2ToV3(state);
       // else if (state.version === 3) state = migrateV3ToV4(state);
       else return getDefaultState();
     }
     return state;
   }
   ```

4. **After migrating, persist and return**  
   When `parsed.version < SETTINGS_VERSION`, call `migrateToLatest(parsed)`, then `saveState(migrated)` so the client’s stored state is updated, and return the migrated state.

5. **Unknown or future version**  
   If `parsed.version > SETTINGS_VERSION` or an unknown step in the loop, fall back to default state (and optionally clear or backup storage) instead of running migrations.

---

## Additive changes: default + spread

To avoid a new migration function for every new optional field:

1. **Single source of truth**  
   Maintain a full `defaultState` (or `DEFAULT_SETTINGS`) that includes every current field. When adding a new optional setting, add it only there.

2. **Merge with stored data on load**  
   After running any structural migrations (see below), merge: `{ ...defaultState, ...parsed }`. Missing keys in stored data get the default; no new `migrateXtoY` needed for additive fields.

3. **Optional inline fixes**  
   When an old version needs a derived value (e.g. a new field that can’t be a literal default), you can do:  
   `const migrated = { ...defaultState, ...parsed }; if (!migrated.newField) migrated.newField = deriveFrom(parsed); return migrated;`  
   Prefer this only when the logic is trivial; otherwise use an explicit migration step.

4. **When to use explicit migrations**  
   Use `migrateVXtoVY` (and bump version) for **structural or breaking changes**: renamed keys, changed types, or reshaped data (e.g. flat → nested). Keep the one-migration-per-version-step rule for those. Additive optional fields stay in default + spread only.
